# CudaPolyImageMaker
The CudaPolyImageMaker consist on the same problem solve in [SimplePolyImageMaker](https://github.com/SergioOyaga/GeneticAlgorithmExamples/blob/master/src/main/java/org/soyaga/examples/ImageMaker/SimplePolyImageMaker)
. But in this case we use the power of CUDA programming to work with images. This is an example on how flexible the 
OptimizationLib framework is. By some simple adjustments we can use any kind of technology during the optimization process.

<table>
  <tr>
    <th colspan="2"> <b>Galaxy (300x300 pixels) </b></th>
  </tr>
  <tr>
    <td> <b>Galaxy evolution </b></td>
    <td> <b>Reference</b> </td>
  </tr>
  <tr>
    <td> <img src="https://github.com/SergioOyaga/GeneticAlgorithmExamples/blob/master/src/out/ImageMaker/galaxy.gif"  title="Solution for the galaxy" alt="Solution for the Galaxy" width="300" height="300" /></td>
    <td> <img src="https://github.com/SergioOyaga/GeneticAlgorithmExamples/blob/master/src/main/resources/ImageMaker/galaxy.jpg"  title="Reference galaxy" alt="Reference galaxy" width="300" height="300" /></td>
  </tr>
  <tr>
    <th colspan="2"> <b>Big Landscape (1920x1280 pixels)</b> </th>
  </tr>
  <tr>
    <td> <b>Geometric Landscape evolution </b></td>
    <td> <b>Reference</b> </td>
  </tr>
  <tr>
    <td> <img src="https://github.com/SergioOyaga/GeneticAlgorithmExamples/blob/master/src/out/ImageMaker/big_landscape.gif"  title="Solution for big landscape" alt="Solution for big landscape" width="300" height="200" /></td>
    <td> <img src="https://github.com/SergioOyaga/GeneticAlgorithmExamples/blob/master/src/main/resources/ImageMaker/big_landscape.png"  title="Reference big landscape" alt="Reference big landscape" width="300" height="200" /></td>
  </tr>
</table>

## In this folder:
We  can find the description of the classes in [SimplePolyImageMaker](https://github.com/SergioOyaga/GeneticAlgorithmExamples/blob/master/src/main/java/org/soyaga/examples/ImageMaker/SimplePolyImageMaker)
. The classes with changes are specify as follows:
1. [PolyImageObjectiveFunction](#polyimageobjectivefunction): Extends ObjectiveFunction.
2. [Kernel](#kernel): Folder with the CUDA kernel.
   1. [ColorDifKernel](#colordifkernel): Class that follows the NVRTC structure to build the kernel.
   2. [JCudaColorDistance.cu](#jcudacolordistancecu): C code for the NVRTC compiler.
3. [RunPolyImageOptimization](#runpolyimageoptimization): This is the main class. Here we instantiate our ChessGA Object with all his 
components.

### [PolyImageObjectiveFunction](https://github.com/SergioOyaga/GeneticAlgorithmExamples/blob/master/src/main/java/org/soyaga/examples/ImageMaker/CudaPolyImageMaker/PolyImageObjectiveFunction.java):
This function evaluates the objective function of a solution. In this case we compute the l~2~ norm for the RGBA colors
from the image generated by the genome against the colors in the real image.

The computation of the difference for each pixel is performed in the GPU using a [custom kernel](#colordifkernel). The 
sum of the values of all pixels are also performed in the GPU, but using the JCublas2 class.
````java
// Move polyImage to device reserved cunk of memory
cuMemcpyHtoD(this.devicePolyImage, Pointer.to(polyImageArray),(long) this.width *this.height * Sizeof.INT);
// Perform pixel color difference in GPU. (result in the Pointer to GPU chunk: this.deviceInternalDifferenceVector)
this.colorDifKernel.runKernel( polyImageArray.length,this.deviceReferenceImage, this.devicePolyImage,this.deviceInternalDifferenceVector);
// Add vector values to gather the result using JCublas2.
JCublas2.cublasDasum(this.handle,this.width *this.height,this.deviceInternalDifferenceVector,1,Pointer.to(result));
````
The rest of the class explanation is similar to what was used in [SimplePolyImageMaker](https://github.com/SergioOyaga/GeneticAlgorithmExamples/blob/master/src/main/java/org/soyaga/examples/ImageMaker/SimplePolyImageMaker)
.

### [Kernel](https://github.com/SergioOyaga/GeneticAlgorithmExamples/blob/master/src/main/java/org/soyaga/examples/ImageMaker/CudaPolyImageMaker/Kernel):
Folder that contains the CUDA kernel class and function file.

1. #### [ColorDifKernel](https://github.com/SergioOyaga/GeneticAlgorithmExamples/blob/master/src/main/java/org/soyaga/examples/ImageMaker/CudaPolyImageMaker/Kernel/ColorDifKernel.java):
   Class that Contains all the information required to build a CUDA custom kernel function, and is able to launch a kernel with these parameters.
2. #### [JCudaColorDistance.cu](https://github.com/SergioOyaga/GeneticAlgorithmExamples/blob/master/src/main/java/org/soyaga/examples/ImageMaker/CudaPolyImageMaker/Kernel/JCudaColorDistance.cu):
   C++ style program that allow us to use the NVRTC (NVidia RunTime Compilation library for C++). This program is loaded
   to a function in the ColorDifKernel class.

   ```cpp
   extern "C"
    __global__ void computeColorDif(int length, int *rgb_ref, int *rgb_poly, double *result)
    {
    int i = blockIdx.x * blockDim.x + threadIdx.x;
    int color1 = rgb_ref[i];
    int color2 = rgb_poly[i];
    int color1b = color1 & 0xff;
    int color1g = (color1 & 0xff00) >> 8;
    int color1r = (color1 & 0xff0000) >> 16;
    int color1a = (color1 & 0xff000000) >> 24;
    int color2b = color2 & 0xff;
    int color2g = (color2 & 0xff00) >> 8;
    int color2r = (color2 & 0xff0000) >> 16;
    int color2a = (color2 & 0xff000000) >> 24;
    double dr = (double)color1r - color2r;
    double dg = (double)color1g - color2g;
    double db = (double)color1b - color2b;
    double da = (double)color1a - color2a;
    result[i] = sqrt(dr * dr + dg * dg + db * db + da * da)/length;
    };
   ```

### [RunPolyImageOptimization](https://github.com/SergioOyaga/GeneticAlgorithmExamples/blob/master/src/main/java/org/soyaga/examples/ImageMaker/CudaPolyImageMaker/RunPolyImageOptimization.java):
Similar to [SimplePolyImageMaker](https://github.com/SergioOyaga/GeneticAlgorithmExamples/blob/master/src/main/java/org/soyaga/examples/ImageMaker/SimplePolyImageMaker).
But we added the path to the cuda c++ style file:
````java
//Ej.: String with the path to the image we want to recreate.
String cudaFileNamePath = "path/to/JCudaColorDistance.cu";
````

## Comment:
Notice that this example is not a good practice for the use of the JCuda framework. In fact, the improvement in 
performance is almost inappreciable because thh time spent moving each image to the GPU is almost the same 
time we would spend computing directly the distance in CPU. However, it is a good example on how we can connect the 
optimization process with foreign precesses (GPU computing, IA forecasts, DeepLearning recommendations...).
(You know what they say, mixing technologies is powerful, but "With great power comes great responsibility" :triumph:)

