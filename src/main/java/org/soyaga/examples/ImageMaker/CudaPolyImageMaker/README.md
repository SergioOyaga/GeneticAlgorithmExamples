# CudaPolyImageMaker
The CudaPolyImageMaker addresses the task of discovering a collection of colored shapes that accurately represents
an image. Historically, this challenge has been commonly exemplified through the recreation of iconic artworks like the
Mona Lisa painting. Nevertheless, it's crucial to recognize that this technique can be applied to virtually any image,
as images can be deconstructed into an arrangement of overlapping shapes. In this case, we harness the power of CUDA 
programming to manipulate images. This example underscores the flexibility of the OptimizationLib framework. 
With a few straightforward adjustments, we can seamlessly integrate various technologies into the optimization process.

<table>
  <tr>
    <th colspan="2"> <b>Galaxy (300x300 pixels) </b></th>
  </tr>
  <tr>
    <td> <b>Galaxy evolution </b></td>
    <td> <b>Reference</b> </td>
  </tr>
  <tr>
    <td> <img src="https://github.com/SergioOyaga/GeneticAlgorithmExamples/blob/master/src/out/ImageMaker/galaxy.gif"  title="Solution for the galaxy" alt="Solution for the Galaxy" width="300" height="300" /></td>
    <td> <img src="https://github.com/SergioOyaga/GeneticAlgorithmExamples/blob/master/src/main/resources/ImageMaker/galaxy.jpg"  title="Reference galaxy" alt="Reference galaxy" width="300" height="300" /></td>
  </tr>
  <tr>
    <th colspan="2"> <b>Big Landscape (1920x1280 pixels)</b> </th>
  </tr>
  <tr>
    <td> <b>Geometric Landscape evolution </b></td>
    <td> <b>Reference</b> </td>
  </tr>
  <tr>
    <td> <img src="https://github.com/SergioOyaga/GeneticAlgorithmExamples/blob/master/src/out/ImageMaker/big_landscape.gif"  title="Solution for big landscape" alt="Solution for big landscape" width="300" height="200" /></td>
    <td> <img src="https://github.com/SergioOyaga/GeneticAlgorithmExamples/blob/master/src/main/resources/ImageMaker/big_landscape.png"  title="Reference big landscape" alt="Reference big landscape" width="300" height="200" /></td>
  </tr>
</table>

## In this folder:
We can find the descriptions of the classes in the [SimplePolyImageMaker](https://github.com/SergioOyaga/GeneticAlgorithmExamples/blob/master/src/main/java/org/soyaga/examples/ImageMaker/SimplePolyImageMaker) directory.
The classes that have undergone changes are specified as follows:
1. [PolyImageObjectiveFunction](#polyimageobjectivefunction): Implements ObjectiveFunction.
2. [Kernel](#kernel): Folder with the CUDA kernel.
   1. [ColorDifKernel](#colordifkernel): Class that follows the NVRTC structure to build the kernel.
   2. [JCudaColorDistance.cu](#jcudacolordistancecu): C code for the NVRTC compiler.
3. [RunPolyImageOptimization](#runpolyimageoptimization): This is the main class. Here we instantiate our 
CustomGeneticAlgorithm Object with all his components.

### [PolyImageObjectiveFunction](https://github.com/SergioOyaga/GeneticAlgorithmExamples/blob/master/src/main/java/org/soyaga/examples/ImageMaker/CudaPolyImageMaker/PolyImageObjectiveFunction.java):
This function is responsible for evaluating the objective function of a solution. In this context, the L~2~ norm is
computed for the RGBA colors in the image generated by the genome, contrasting them with the colors in the actual image.

The outcome of this function is a Double value, representing the ratio of Euclidean color deviation per pixel across
the entire generated image when compared to the reference image.

The computation of the difference for each pixel is carried out in the GPU using a [custom kernel](#colordifkernel). 
Additionally, the summation of pixel values is conducted on the GPU using the JCublas2 class.

````java
// Move polyImage to device reserved cunk of memory
cuMemcpyHtoD(this.devicePolyImage, Pointer.to(polyImageArray),(long) this.width *this.height * Sizeof.INT);
// Perform pixel color difference in GPU. (result in the Pointer to GPU chunk: this.deviceInternalDifferenceVector)
this.colorDifKernel.runKernel( polyImageArray.length,this.deviceReferenceImage, this.devicePolyImage,this.deviceInternalDifferenceVector);
// Add vector values to gather the result using JCublas2.
JCublas2.cublasDasum(this.handle,this.width *this.height,this.deviceInternalDifferenceVector,1,Pointer.to(result));
````

### [Kernel](https://github.com/SergioOyaga/GeneticAlgorithmExamples/blob/master/src/main/java/org/soyaga/examples/ImageMaker/CudaPolyImageMaker/Kernel):
Folder that contains the CUDA kernel class and function file.

1. #### [ColorDifKernel](https://github.com/SergioOyaga/GeneticAlgorithmExamples/blob/master/src/main/java/org/soyaga/examples/ImageMaker/CudaPolyImageMaker/Kernel/ColorDifKernel.java):
   Class that Contains all the information required to build a CUDA custom kernel function, and is able to launch a kernel with these parameters.
2. #### [JCudaColorDistance.cu](https://github.com/SergioOyaga/GeneticAlgorithmExamples/blob/master/src/main/java/org/soyaga/examples/ImageMaker/CudaPolyImageMaker/Kernel/JCudaColorDistance.cu):
   C++ style program that allows us to use the NVRTC (NVidia RunTime Compilation library for C++). This program is loaded
   to a function in the ColorDifKernel class.

   ```cpp
   extern "C"
    __global__ void computeColorDif(int length, int *rgb_ref, int *rgb_poly, double *result)
    {
    int i = blockIdx.x * blockDim.x + threadIdx.x;
    int color1 = rgb_ref[i];
    int color2 = rgb_poly[i];
    int color1b = color1 & 0xff;
    int color1g = (color1 & 0xff00) >> 8;
    int color1r = (color1 & 0xff0000) >> 16;
    int color1a = (color1 & 0xff000000) >> 24;
    int color2b = color2 & 0xff;
    int color2g = (color2 & 0xff00) >> 8;
    int color2r = (color2 & 0xff0000) >> 16;
    int color2a = (color2 & 0xff000000) >> 24;
    double dr = (double)color1r - color2r;
    double dg = (double)color1g - color2g;
    double db = (double)color1b - color2b;
    double da = (double)color1a - color2a;
    result[i] = sqrt(dr * dr + dg * dg + db * db + da * da)/length;
    };
   ```

### [RunPolyImageOptimization](https://github.com/SergioOyaga/GeneticAlgorithmExamples/blob/master/src/main/java/org/soyaga/examples/ImageMaker/CudaPolyImageMaker/RunPolyImageOptimization.java):
Similar to [SimplePolyImageMaker](https://github.com/SergioOyaga/GeneticAlgorithmExamples/blob/master/src/main/java/org/soyaga/examples/ImageMaker/SimplePolyImageMaker).
But we added the path to the cuda c++ style file:
````java
//Ej.: String with the path to the image we want to recreate.
String cudaFileNamePath = "path/to/JCudaColorDistance.cu";
````

## Comment:
Notice that this example does not exemplify good practice in the utilization of the JCuda framework. In fact, the 
enhancement in performance is nearly imperceptible due to the comparable time spent transferring each image to the GPU 
and the time it would take to directly compute the distance on the CPU. Nonetheless, it serves as a compelling 
illustration of how we can establish connections between the optimization process and external processes, such as
GPU computing, AI predictions, and Deep Learning recommendations.
As the saying goes, harnessing the power of mixed technologies is formidable, yet it also carries the weight of 
"With great power comes great responsibility" :triumph:


